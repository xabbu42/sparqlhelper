#!/usr/bin/env perl

=head1 NAME

sparqlhelper - Simplify SparQL query formulation on the command line.

C<sparqlhelper> uses the given sparql where clause to construct a
complete query, by selecting distinct values for all not repeated
variable names longer than one char in the where clause. So the query
C<?s a ?class> selects and outputs all distinct classes in the data
set. Moreover, known prefixes used in the where clause are added from
the data of http://prefix.cc.

The complete sparql query is per default just output to stdout, but
can be directly passed on to arq for convenience. This is enabled by
passing some arq options like C<--data> or C<--service> to the command
line. In this case, also all known prefixes from prefix.cc are added
to the query.

=head1 SYNOPSIS

sparqlhelper [OPTIONS] QUERY

 --help|-h      Brief help message
 --data|-d      Data file to use (passed on to arq)
 --service|-s   Service endpoint to use (passed on to arq)
 --prefix|-p    Add a prefix to the query in the form prefix=uri.
                Known prefixes from prefix.cc are recognized instead 
                of a uri.


=head1 AUTHOR

 Nathan Gass <gass@search.ch>

=cut

use strict;
use warnings;
use v5.010;

use Getopt::Long qw/:config/;
use List::MoreUtils qw/uniq/;
use YAML;
use Pod::Usage;
use LWP::Simple qw/mirror/;

my $opts = {};
GetOptions(
	$opts,
	'help|h', 'data|d=s', 'service|s=s', 'prefix|p=s%',
	) or pod2usage(2);
pod2usage() if $opts->{help};

my $query = shift // pod2usage(2);

my %prefixmap;
my $path = $ENV{HOME} . '/.sparqlhelper.prefix.cc';
mirror('http://prefix.cc/popular/all', $path);
my @matches = (`cat $path` =~ /resource="([^"]+)".*?href="([^"]+)"/g);
while (@matches) {
	my $uri    = shift @matches;
	my $prefix = shift @matches;
	$prefixmap{$prefix} = $uri;
}

my @vars = ($query =~ m/\?\w+/g);
if (!$opts->{data} && !$opts->{service}) {
	my %used = map {s/://; $_ => 1} ($query =~ m/\b\w+:/g);
	foreach my $key (keys %prefixmap) {
		delete $prefixmap{$key} unless $used{$key};
	}
}
$prefixmap{$_} = $prefixmap{$opts->{prefix}{$_}} || $opts->{prefix}{$_} foreach keys %{$opts->{prefix}};

my %counts;
$counts{$_}++ foreach @vars;

my $select = join " ", grep {length($_) > 2 && $counts{$_} == 1} @vars;
my $result =
	join("\n", map {"PREFIX $_: <" . $prefixmap{$_} . ">"} keys %prefixmap)
	. (%prefixmap ? "\n" : '')
	. "SELECT DISTINCT $select WHERE { $query } ORDER BY $select";

if ($opts->{data} || $opts->{service}) {
	my @args;
	foreach my $key (qw/data service/) {
		push @args, '--' . $key, $opts->{$key} if $opts->{$key};
	}
	system('arq', @args, $result);
} else {
	say $result;
}

